(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _class;

require('whatwg-fetch');

var _component = require('@reduct/component');

var _nitpick = require('@reduct/nitpick');

var _nitpick2 = _interopRequireDefault(_nitpick);

var _hashChange = require('hash-change');

var _hashChange2 = _interopRequireDefault(_hashChange);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var serviceUrlPattern = '/ttree/outofbandrendering?preset=marketplace:version&node={{ path }}&version={{ version }}';

var PackageVersionBrowserComponent = (_dec = (0, _component.component)({
  version: _nitpick2.default.string.isRequired,
  path: _nitpick2.default.string.isRequired
}), _dec(_class = function () {
  function PackageVersionBrowserComponent() {
    var _this = this;

    _classCallCheck(this, PackageVersionBrowserComponent);

    this.version = this.props.version;
    this.wrapper = document.createElement('div');

    _hashChange2.default.on('change', function (hash) {
      var _hash$split = hash.split(':');

      var _hash$split2 = _slicedToArray(_hash$split, 2);

      var label = _hash$split2[0];
      var version = _hash$split2[1];

      if (label === undefined || label !== 'version' || version === undefined || _this.version === version) {
        return;
      }
      _this.load(version);
    });
  }

  _createClass(PackageVersionBrowserComponent, [{
    key: 'load',
    value: function load(version) {
      var _this2 = this;

      var path = this.props.path;


      var url = serviceUrlPattern.replace('{{ path }}', path).replace('{{ version }}', version);

      fetch(url).then(function (response) {
        return response.text();
      }).then(function (body) {
        _this2.wrapper.innerHTML = body;
        var article = _this2.wrapper.querySelector('article');

        while (_this2.el.firstChild) {
          _this2.el.removeChild(_this2.el.firstChild);
        }

        _this2.el.appendChild(article);
        _this2.version = version;
      });
    }
  }]);

  return PackageVersionBrowserComponent;
}()) || _class);
exports.default = PackageVersionBrowserComponent;

},{"@reduct/component":6,"@reduct/nitpick":7,"hash-change":10,"whatwg-fetch":11}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _class;

var _component = require('@reduct/component');

var _nitpick = require('@reduct/nitpick');

var _nitpick2 = _interopRequireDefault(_nitpick);

var _domAddClass = require('dom-add-class');

var _domAddClass2 = _interopRequireDefault(_domAddClass);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShowMoreComponent = (_dec = (0, _component.component)({
  maximumHeight: _nitpick2.default.number.isRequired,
  selector: _nitpick2.default.string.isRequired,
  targetClass: _nitpick2.default.string.isRequired,
  buttonClass: _nitpick2.default.string.isRequired,
  wrapperClass: _nitpick2.default.string.isRequired,
  iconClass: _nitpick2.default.string.isRequired
}), _dec(_class = function () {
  _createClass(ShowMoreComponent, [{
    key: 'getDefaultProps',
    value: function getDefaultProps() {
      return {
        maximumHeight: 210,
        wrapperClass: 'show-more',
        targetClass: 'show-more__target',
        buttonClass: 'show-more__button',
        iconClass: 'fa fa-chevron-down'
      };
    }
  }]);

  function ShowMoreComponent() {
    _classCallCheck(this, ShowMoreComponent);

    var _props = this.props;
    var maximumHeight = _props.maximumHeight;
    var selector = _props.selector;

    this.target = this.el.querySelector(selector);
    this.state.isOpen = true;

    if (!this.target) {
      return;
    }

    var offsetHeight = this.target.offsetHeight;


    this.init();
    if (offsetHeight > maximumHeight) {
      this.enable();
    } else {
      this.open();
    }
  }

  _createClass(ShowMoreComponent, [{
    key: 'init',
    value: function init() {
      var _props2 = this.props;
      var wrapperClass = _props2.wrapperClass;
      var targetClass = _props2.targetClass;

      (0, _domAddClass2.default)(this.el, wrapperClass);
      (0, _domAddClass2.default)(this.target, targetClass);
    }
  }, {
    key: 'enable',
    value: function enable() {
      this.close();
      this.appendButton();
    }
  }, {
    key: 'appendButton',
    value: function appendButton() {
      var that = this;
      var button = document.createElement('button');
      var _props3 = this.props;
      var buttonClass = _props3.buttonClass;
      var iconClass = _props3.iconClass;

      (0, _domAddClass2.default)(button, buttonClass);

      var icon = document.createElement('i');
      (0, _domAddClass2.default)(icon, iconClass);

      button.appendChild(icon);
      button.addEventListener('click', function (e) {
        e.preventDefault();
        that.toggle();
      });

      this.el.appendChild(button);
    }
  }, {
    key: 'toggle',
    value: function toggle() {
      if (this.state.isOpen === false) {
        this.open();
      } else {
        this.close();
      }
    }
  }, {
    key: 'close',
    value: function close() {
      this.target.style.height = this.props.maximumHeight + 'px';
      this.state.isOpen = false;
    }
  }, {
    key: 'open',
    value: function open() {
      this.target.style.height = null;
      this.state.isOpen = true;
    }
  }]);

  return ShowMoreComponent;
}()) || _class);
exports.default = ShowMoreComponent;

},{"@reduct/component":6,"@reduct/nitpick":7,"dom-add-class":8}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.PackageVersionBrowser = exports.ShowMore = undefined;

var _ShowMore = require('./ShowMore.js');

var _ShowMore2 = _interopRequireDefault(_ShowMore);

var _PackageVersionBrowser = require('./PackageVersionBrowser.js');

var _PackageVersionBrowser2 = _interopRequireDefault(_PackageVersionBrowser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.ShowMore = _ShowMore2.default;
exports.PackageVersionBrowser = _PackageVersionBrowser2.default;

},{"./PackageVersionBrowser.js":1,"./ShowMore.js":2}],4:[function(require,module,exports){
'use strict';

var _assembler = require('@reduct/assembler');

var _assembler2 = _interopRequireDefault(_assembler);

var _Components = require('./Components/');

var components = _interopRequireWildcard(_Components);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var app = (0, _assembler2.default)();

app.registerAll(components);

setTimeout(function () {
  return app.run();
}, 0);
document.addEventListener('Neos.PageLoaded', app.run());

},{"./Components/":3,"@reduct/assembler":5}],5:[function(require,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.reduct || (g.reduct = {})).assembler = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
/**
 *
 * @name @reduct/logger
 * @version 1.1.0
 * @license MIT
 *
 * @author Tyll Weiß <inkdpixels@gmail.com>
 * @author André König <andre.koenig@posteo.de>
 * @author Wilhelm Behncke
 *
 */


(function () {
    var reductOpts = {
        isTestingEnv: false,
        packageVersion: {
            major: 1,
            minor: 1,
            patch: 0
        }
    };
    var world = this;

    // Check for globals.
    if (typeof window !== "undefined") {
        world = window;
    } else if (typeof global !== "undefined") {
        world = global;
    } else if (typeof self !== "undefined") {
        world = self;
    }

    // Execute the isTestingEnv check.
    reductOpts.isTestingEnv = world.process && world.process.title && !!~world.process.title.indexOf('reduct');

    return (function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.logger = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
/*global reductOpts*/

/**
 * @private
 *
 * Checks if the given argument is a Number.
 *
 * @param num {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _isNumeric(num) {
    return !isNaN(num);
}

var logLevels = {
    ALL: 2,
    WARNINGS: 1,
    SILENT: 0
};

var Logger = (function () {
    /**
     * Sets up internal properties for the logger.
     *
     * @param namespace {String} The optional namespace for the logger.
     * @param logLevel {Number} The optional initial logLevel for the logger.
     */

    function Logger() {
        var namespace = arguments.length <= 0 || arguments[0] === undefined ? '@reduct/logger' : arguments[0];
        var logLevel = arguments.length <= 1 || arguments[1] === undefined ? logLevels.ALL : arguments[1];

        _classCallCheck(this, Logger);

        this.version = reductOpts.packageVersion;
        this.logLevel = logLevel;
        this.namespace = namespace;

        this.instances = [];
    }

    //
    // Check for the existence of an logger instance in the global namespace,
    // and if none was found create a singleton.
    //

    /**
     * Returns customized version of the logger API.
     *
     * @param namespace {String} The namespace of the new logger instance.
     */

    _createClass(Logger, [{
        key: 'getLogger',
        value: function getLogger() {
            var namespace = arguments.length <= 0 || arguments[0] === undefined ? this.namespace : arguments[0];

            var logger = new Logger(namespace, this.logLevel);

            this.instances.push(logger);

            return {
                log: function log(message, appendix) {
                    logger.log(message, appendix);
                },

                info: function info(message, appendix) {
                    logger.info(message, appendix);
                },

                warn: function warn(message, appendix) {
                    logger.warn(message, appendix);
                },

                error: function error(message, appendix) {
                    logger.error(message, appendix);
                }
            };
        }

        /**
         * Adjusts the noise of the centralized instance of the logger.
         * 0 => No messages are displayed
         * 1 => Only severe messages are displayed
         * 2 => Every message is displayed
         *
         * @param int {Number} The new log level.
         * @returns {Logger}
         *
         */
    }, {
        key: 'setLogLevel',
        value: function setLogLevel(int) {
            var logLevel = _isNumeric(int) ? int : 2;

            this.logLevel = logLevel;

            this.instances.forEach(function (logger) {
                logger.logLevel = logLevel;
            });

            return this;
        }

        /**
         * Logs a message to the console API if possible.
         *
         * @param message {String} The message to log.
         * @param appendix {*} An optional appendix for the log.
         * @returns {Logger}
         *
         */
    }, {
        key: 'log',
        value: function log(message) {
            var appendix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

            if (this.logLevel < logLevels.ALL) {
                return this;
            }

            try {
                console.log(this.namespace + ': ' + message, appendix);
            } catch (e) {}

            return this;
        }

        /**
         * Logs a info to the console API if possible.
         *
         * @param message {String} The message to log.
         * @param appendix {*} An optional appendix for the info log.
         * @returns {Logger}
         *
         */
    }, {
        key: 'info',
        value: function info(message) {
            var appendix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

            if (this.logLevel < logLevels.ALL) {
                return this;
            }

            try {
                console.info(this.namespace + ' Info: ' + message, appendix);
            } catch (e) {}

            return this;
        }

        /**
         * Logs a warning to the console API if possible.
         *
         * @param message {String} The message to log.
         * @param appendix {*} An optional appendix for the warning.
         * @returns {Logger}
         *
         */
    }, {
        key: 'warn',
        value: function warn(message) {
            var appendix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

            if (this.logLevel < logLevels.WARNINGS) {
                return this;
            }

            try {
                console.warn(this.namespace + ' Warning: ' + message, appendix);
            } catch (e) {}
        }

        /**
         * Logs a error to the console API if possible.
         *
         * @param message {String} The message to log.
         * @param appendix {*} An optional appendix for the error log.
         * @returns {Logger}
         *
         */
    }, {
        key: 'error',
        value: function error(message) {
            var appendix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

            if (this.logLevel < logLevels.SILENT) {
                return this;
            }

            if (appendix !== '') {
                try {
                    // We still need the console.error call since the Error object can't print out references to HTML Elements/Objects etc.
                    console.error(message, appendix);
                } catch (e) {}

                throw new Error(this.namespace + ' Error: Details are posted above.');
            } else {
                throw new Error(this.namespace + ' Error: ' + message);
            }
        }
    }]);

    return Logger;
})();

if (!(global.reductLogger instanceof Logger)) {
    var logger = new Logger();

    //
    // Reduce the logging noise for the unit tests.
    //
    if (reductOpts.isTestingEnv) {
        logger.setLogLevel(0);
    }

    global.reductLogger = logger;
}

exports['default'] = {
    logger: global.reductLogger,
    logLevels: logLevels
};
module.exports = exports['default'];

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[1])(1)
});
}());
                
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(_dereq_,module,exports){
(function (process){
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _logger = _dereq_('@reduct/logger');

function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assemblerLogger = _logger.logger.getLogger('@reduct/assembler');

/**
 * The Assembler.
 *
 * An assembler instance acts as the central point of your
 * application. It is responsible for connecting DOM nodes with
 * actual component instances through exposed interfaces. Those
 * interfaces provides the functionality for registering component
 * classes and bootstrapping the whole application.
 *
 * Usage example:
 *
 *	 import assembler from 'assembler';
 *
 *	 // Importing your actual components
 *	 import MyComponent from 'my-component';
 *	 import AnotherComponent from 'another-component';
 *
 *	 const app = assembler();
 *
 *	 app.register(MyComponent);
 *	 app.register(AnotherComponent, 'NewsComponent');
 *
 *	 // Start the application (will parse the DOM and mount the
 *	 // component instances).
 *	 app.run();
 *
 */

var Assembler = (function () {

	/**
  * Initializes the empty component class index
  * and the actual component instance cache.
  *
  * @param {object} opts Overwritten default options
  *
  */

	function Assembler() {
		var opts = arguments.length <= 0 || arguments[0] === undefined ? { marker: 'component' } : arguments[0];

		_classCallCheck(this, Assembler);

		this.marker = opts.marker;
		this.selector = 'data-' + this.marker;

		this.index = {};

		//
		// The actual instantiated components.
		//
		// Structure:
		//
		//	 {
		//		 'ComponentClassName': [object, object],
		//		 'YetAnotherComponentClassName': [object]
		//	 }
		//
		this.components = {};

		//
		// A cache of DOM elements.
		//
		// This is for checking if a component has already been instantiated.
		//
		// TODO: Refactoring: Find another way (with good performance) to combine this
		// array with the `components` object.
		//
		this.elements = [];
	}

	/**
 * @private
 *
 * Parses the function name out of `Function.prototype.toString()`.
 *
 * TODO: Move into Utilities when supported by `build-tools`.
 *
 * @param {Function} The function from which the name should be extracted.
 * @returns {string} The actual name (`anonymous` when the function does not provide a name).
 *
 */

	_createClass(Assembler, [{
		key: 'getFunctionName',
		value: function getFunctionName(fn) {
			if (Reflect.apply(Object.prototype.toString, fn, fn) !== '[object Function]') {
				assemblerLogger.error(fn + ' is not a valid function.');
			}

			var regexe = /^\s*function\s*([^\(]*)/im;

			return fn.name || regexe.exec(fn.toString())[1] || 'anonymous';
		}

		/**
   * @private
   *
   * Checks if a component has already been instantiated.
   *
   * @param {DOMElement} element The element which should be connected to a component.
   *
   * @returns {boolean}
   *
   */

	}, {
		key: 'isInstantiated',
		value: function isInstantiated(element) {
			return this.elements.indexOf(element) !== -1;
		}

		/**
   * @private
   *
   * Instantiates a component by a given DOM node.
   *
   * Will extract the component's name out of the DOM nodes `data`
   * attribute, instantiates the actual component object and pushes
   * the instance to the internal `components` index.
   *
   * @param {HTMLElement} element The component's root DOM node.
   *
   */

	}, {
		key: 'instantiate',
		value: function instantiate(element) {
			if (!this.isInstantiated(element)) {
				var name = element.getAttribute(this.selector);
				var instantiatedTargets = this.components[name] || [];

				var components = this.components[name] = Reflect.apply(Array.prototype.slice, instantiatedTargets, instantiatedTargets);
				var Component = this.index[name];

				this.elements.unshift(element);

				components.unshift(new Component(element));
			}
		}

		/**
   * Registers a component class.
   *
   * Usage example
   *
   *	 app.register(MyComponent); // Name: 'MyComponent'
   *
   *	 app.register(MyComponent, 'FooComponent'); // Name: 'FooComponent'
   *
   * @param {Function} ComponentClass The component class which should be registered.
   * @param {string} name An alternative name (optional)
   *
   */

	}, {
		key: 'register',
		value: function register(ComponentClass, name) {
			var type = typeof ComponentClass === 'undefined' ? 'undefined' : _typeof(ComponentClass);

			if (type !== 'function') {
				throw new Error('\'' + type + '\' is not a valid component class.');
			}

			name = name || this.getFunctionName(ComponentClass);

			this.index[name] = ComponentClass;

			return this;
		}

		/**
   * Takes a hashmap with multiple component classes
   * and registers them at once.
   *
   * Usage example:
   *
   *	 app.registerAll({
   *		 MyComponent: MyComponent,		// name: 'MyComponent'
   *		 'AnotherComponent': FooComponent // name: 'AnotherComponent'
   *	 });
   *
   *	 // With destructuring
   *	 app.registerAll({MyComponent, FooComponent});
   *
   * @param {object} classMap A map with multiple component classes.
   *
   */

	}, {
		key: 'registerAll',
		value: function registerAll(classMap) {
			var _this = this;

			Object.keys(classMap).forEach(function (name) {
				return _this.register(classMap[name], name);
			});

			return this;
		}

		/**
   * "Parse" the DOM for component declarations and
   * instantiate the actual, well, components.
   *
   */

	}, {
		key: 'run',
		value: function run() {
			var _this2 = this;

			var nodeList = document.querySelectorAll('[' + this.selector + ']');
			var elements = Reflect.apply(Array.prototype.slice, nodeList, [nodeList]);
			var names = Object.keys(this.index);

			//
			// Find all instantiable elements.
			// Note: `getAttribute` has to be used due to: https://github.com/tmpvar/jsdom/issues/961
			//
			elements.filter(function (element) {
				return names.indexOf(element.getAttribute(_this2.selector)) !== -1;
			}).forEach(function (element) {
				return _this2.instantiate(element);
			});
		}
	}]);

	return Assembler;
})();

//
// Create the `assembler` factory function.
// This factory will create a new instance of the `assembler` and exposes the API
//

var assembler = function assembler(opts) {
	var assembler = new Assembler(opts);

	//
	// Shard the actual front-facing API (for not leaking private methods and properties).
	//
	var api = {
		register: function register(ComponentClass, name) {
			return assembler.register(ComponentClass, name);
		},
		registerAll: function registerAll(classMap) {
			return assembler.registerAll(classMap);
		},
		run: function run() {
			return assembler.run();
		}
	};

	//
	// Expose additional attributes for the tests.
	//
	try {
		if (process.env.TEST) {
			api.index = assembler.index;
			api.components = assembler.components;
		}
	} catch (e) {}

	return api;
};

exports.default = assembler;

}).call(this,_dereq_('_process'))
},{"@reduct/logger":1,"_process":2}]},{},[3])(3)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],6:[function(require,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.reduct || (g.reduct = {})).Component = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.reduct || (g.reduct = {})).loggerPackage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(_dereq_,module,exports){
(function (process,global){
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 *
 * Checks if the given argument is a Number.
 *
 * @param num {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function _isNumeric(num) {
	return !isNaN(num);
}

var logLevels = {
	ALL: 2,
	WARNINGS: 1,
	SILENT: 0
};

var Logger = (function () {
	/**
  * Sets up internal properties for the logger.
  *
  * @param namespace {String} The optional namespace for the logger.
  * @param logLevel {Number} The optional initial logLevel for the logger.
  */

	function Logger() {
		var namespace = arguments.length <= 0 || arguments[0] === undefined ? '@reduct/logger' : arguments[0];
		var logLevel = arguments.length <= 1 || arguments[1] === undefined ? logLevels.ALL : arguments[1];

		_classCallCheck(this, Logger);

		this.logLevel = logLevel;
		this.namespace = namespace;

		this.instances = [];
	}

	/**
  * Returns customized version of the logger API.
  *
  * @param namespace {String} The namespace of the new logger instance.
  */

	_createClass(Logger, [{
		key: 'getLogger',
		value: function getLogger() {
			var namespace = arguments.length <= 0 || arguments[0] === undefined ? this.namespace : arguments[0];

			var logger = new Logger(namespace, this.logLevel);

			this.instances.push(logger);

			return {
				log: function log(message, appendix) {
					logger.log(message, appendix);
				},

				info: function info(message, appendix) {
					logger.info(message, appendix);
				},

				warn: function warn(message, appendix) {
					logger.warn(message, appendix);
				},

				error: function error(message, appendix) {
					logger.error(message, appendix);
				}
			};
		}

		/**
   * Adjusts the noise of the centralized instance of the logger.
   * 0 => No messages are displayed
   * 1 => Only severe messages are displayed
   * 2 => Every message is displayed
   *
   * @param int {Number} The new log level.
   * @returns {Logger}
   *
   */

	}, {
		key: 'setLogLevel',
		value: function setLogLevel(int) {
			var logLevel = _isNumeric(int) ? int : 2;

			this.logLevel = logLevel;

			this.instances.forEach(function (logger) {
				logger.logLevel = logLevel;
			});

			return this;
		}

		/**
   * Logs a message to the console API if possible.
   *
   * @param message {String} The message to log.
   * @param appendix {*} An optional appendix for the log.
   * @returns {Logger}
   *
   */

	}, {
		key: 'log',
		value: function log(message) {
			var appendix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

			if (this.logLevel < logLevels.ALL) {
				return this;
			}

			try {
				console.log(this.namespace + ': ' + message, appendix);
			} catch (e) {}

			return this;
		}

		/**
   * Logs a info to the console API if possible.
   *
   * @param message {String} The message to log.
   * @param appendix {*} An optional appendix for the info log.
   * @returns {Logger}
   *
   */

	}, {
		key: 'info',
		value: function info(message) {
			var appendix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

			if (this.logLevel < logLevels.ALL) {
				return this;
			}

			try {
				console.info(this.namespace + ' Info: ' + message, appendix);
			} catch (e) {}

			return this;
		}

		/**
   * Logs a warning to the console API if possible.
   *
   * @param message {String} The message to log.
   * @param appendix {*} An optional appendix for the warning.
   * @returns {Logger}
   *
   */

	}, {
		key: 'warn',
		value: function warn(message) {
			var appendix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

			if (this.logLevel < logLevels.WARNINGS) {
				return this;
			}

			try {
				console.warn(this.namespace + ' Warning: ' + message, appendix);
			} catch (e) {}
		}

		/**
   * Logs a error to the console API if possible.
   *
   * @param message {String} The message to log.
   * @param appendix {*} An optional appendix for the error log.
   * @returns {Logger}
   *
   */

	}, {
		key: 'error',
		value: function error(message, appendix) {
			if (this.logLevel < logLevels.SILENT) {
				return this;
			}

			if (appendix) {
				try {
					// We still need the console.error call since the Error object can't print out references to HTML Elements/Objects etc.
					console.error(message, appendix);
				} catch (e) {}

				throw new Error(this.namespace + ' Error: Details are posted above.');
			} else {
				throw new Error(this.namespace + ' Error: ' + message);
			}
		}
	}]);

	return Logger;
})();

//
// Check for the existence of the global reduct object,
// this is duplicate code, but we can't access it otherwise
// since the browserify initialization hooks in later and only in module-system free environments.
//

if (!global.reduct) {
	global.reduct = {};
}

//
// Check for the existence of an logger instance in the global namespace,
// and if none was found create a singleton.
//
if (!(global.reduct.logger instanceof Logger)) {
	var _logger = new Logger();

	//
	// Reduce the logging noise for the unit tests.
	//
	try {
		if (process.env.TEST) {
			_logger.setLogLevel(logLevels.SILENT);
		}
	} catch (e) {}

	global.reduct.logger = _logger;
}

var logger = global.reduct.logger;

exports.logger = logger;
exports.logLevels = logLevels;

}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":1}]},{},[2])(2)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":2}],2:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(_dereq_,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.component = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _logger = _dereq_('@reduct/logger');

var _utilities = _dereq_('./utilities/');

var _messages = _dereq_('./messages.js');

var messages = _interopRequireWildcard(_messages);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

console.log(_utilities.prototype);
var componentLogger = _logger.logger.getLogger('@reduct/component');
var extractFrom = _utilities.prototype.extractFrom;
var injectInto = _utilities.prototype.injectInto;

/**
 * Helper function to move passed props via constructor into the component
 * instance and validate them along the way.
 *
 * @param {Function} context The component instance.
 * @param {Object} passedProps An optional props object which can be directly passed to the class.
 * @returns {Void}
 */

function _validateAndSetProps(context, passedProps) {
	var el = context.el;
	var getDefaultProps = context.getDefaultProps;

	var defaultProps = getDefaultProps();
	var propTypes = context.constructor.propTypes || {};
	var componentName = context.constructor.name;
	var propNames = Object.keys(propTypes);
	var props = {};

	if (!(0, _utilities.isObject)(defaultProps)) {
		_logger.logger.error('The getDefaultProps() method of Component "' + componentName + '" did not return a valid Object. This can lead to unexpected behavior and Errors.');
	}

	//
	// First of, we need to aggregate all props, either from the passed props, the dom or the getDefaultProps() method.
	//
	propNames.forEach(function (propName) {
		var value = passedProps[propName] || el.getAttribute('data-' + propName.toLowerCase()) || defaultProps[propName];

		props[propName] = value;
	});

	//
	// After the aggregation is done, we validate the generated props object with each propType validator.
	// If the user passed an object containing a `isOptional` function as the propType, we map the propType to the function.
	// This reduces the overal code needed to defined propTypes and increases similarity with Reacts syntax.
	//
	propNames.forEach(function (propName) {
		var propTypeTarget = propTypes[propName];
		var propType = (0, _utilities.isObject)(propTypeTarget) && (0, _utilities.isFunction)(propTypeTarget.isOptional) ? propTypeTarget.isOptional : propTypeTarget;
		var isPropTypeInvalid = !(0, _utilities.isFunction)(propType);

		if (isPropTypeInvalid) {
			_logger.logger.error('Invalid propType "' + propName + '" specified in Component "' + componentName + '". Please specify a function as the propType validator.');
		}

		var propTypeResult = propType(props, propName, componentName);

		if ((0, _utilities.isError)(propTypeResult)) {
			_logger.logger.error('The propType for "' + propName + '" in Component "' + componentName + '" returned an Error with the message:\n\n"' + propTypeResult.message + '".');
		}

		//
		// If no error was thrown, and the propType has returned a transformed value,
		// which is not `null` or `undefined`, overwrite the aggregated value.
		//
		if ((0, _utilities.isDefined)(propTypeResult)) {
			props[propName] = propTypeResult;
		}
	});

	// Freeze the props object to avoid further editing off the object.
	context.props = Object.freeze(props);
}

/**
 * Helper function to set initial state variables in the component
 * instance.
 *
 * @param {Function} context The component instance.
 * @returns {Void}
 */
function _setInitialStates(context) {
	var initialState = context.getInitialState();

	if ((0, _utilities.isObject)(initialState)) {
		context.initialStateKeys = Object.keys(initialState);
		context.setState(initialState);
	} else {
		componentLogger.warn('Please return a valid object in the getInitialState() method of "' + context.constructor.name + '".');
	}
}

var ComponentClass = function () {
	function ComponentClass(element, props) {
		_classCallCheck(this, ComponentClass);

		// Fail-Safe mechanism if someone is passing an array or the like as a second argument.
		props = (0, _utilities.isObject)(props) ? props : {};

		if (!(0, _utilities.isDefined)(element)) {
			componentLogger.warn(messages.noElement);
		}

		// The element property for the getElement() method.
		this.el = element || global.document.createElement('div');

		// Holds all props.
		this.props = {};

		// Holds the components state.
		this.state = {};

		// Holds all event listeners.
		this.observers = {};

		// Cache for not hitting the DOM over and over again in the `find` and `findOne` methods.
		this.queryCache = {};

		// Holds all keys of the initial state, used to check for the initial existence of state additions.
		this.initialStateKeys = [];

		// Set the props and the initial state of the component.
		_validateAndSetProps(this, props);
		_setInitialStates(this);
	}

	/**
  * Returns the HTML Element on which the Component was mounted upon.
  *
  * @returns {HTMLElement}
  *
  */


	_createClass(ComponentClass, [{
		key: 'getElement',
		value: function getElement() {
			return this.el;
		}

		/**
   * Returns the next found child node by a given selector.
   *
   * @returns {HTMLElement}
   *
   */

	}, {
		key: 'find',
		value: function find(selector) {
			return this.findAll(selector).shift();
		}

		/**
   * Returns all found child nodes by a given selector.
   *
   * @returns {Array<HTMLElement>}
   *
   */

	}, {
		key: 'findAll',
		value: function findAll(selector) {
			var cachedResult = this.queryCache[selector];

			if (cachedResult) {
				return cachedResult;
			}

			var nodeList = this.getElement().querySelectorAll(selector);
			var nodes = Reflect.apply(Array.prototype.slice, nodeList, [nodeList]);

			this.queryCache[selector] = [].concat(_toConsumableArray(nodes));

			return nodes;
		}

		/**
   * The default method which declares the default properties of the Component.
   *
   * @returns {Object} The object containing default props.
   *
   */

	}, {
		key: 'getDefaultProps',
		value: function getDefaultProps() {
			return {};
		}

		/**
   * Returns a boolean regarding the existence of the property.
   *
   * @param propName {String} The name of the property.
   * @returns {boolean} The result of the check.
   *
   */

	}, {
		key: 'hasProp',
		value: function hasProp(propName) {
			return (0, _utilities.isDefined)(this.props[propName]);
		}

		/**
   * The default method which declares the default state of the Component.
   *
   * @returns {Object} The object containing default state.
   *
   */

	}, {
		key: 'getInitialState',
		value: function getInitialState() {
			return {};
		}

		/**
   * Sets all differing state key/value pairs to the Components state.
   *
   * @param delta {Object} The diff object which holds all state changes for the component.
   * @param opts {Object} Optional options object which f.e. could turn off state events from firing.
   */

	}, {
		key: 'setState',
		value: function setState() {
			var delta = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
			var opts = arguments.length <= 1 || arguments[1] === undefined ? { silent: false } : arguments[1];

			var isNotSilent = !opts.silent;
			var previousState = (0, _utilities.cloneObject)(this.state);
			var initialStateKeys = this.initialStateKeys;


			for (var key in delta) {
				if (delta.hasOwnProperty(key)) {
					var newValue = delta[key];
					var oldValue = previousState[key];

					if (initialStateKeys.indexOf(key) === -1) {
						componentLogger.error('Please specify an initial value for \'' + key + '\' in your getInitialState() method of "' + this.constructor.name + '".');
					} else if (newValue !== oldValue) {
						this.state[key] = newValue;

						if (isNotSilent) {
							this.trigger('change:' + key, {
								key: key,
								value: newValue,
								previousValue: oldValue
							});
						}
					}
				}
			}

			// Trigger event
			if (isNotSilent) {
				this.trigger('change', {
					delta: delta,
					previousState: previousState
				});
			}
		}

		/**
   * Declares a event listener on the given event name.
   *
   * @param event {String} The name of the event under which the listener will be saved under.
   * @param listener {Function} The listener which will be executed once the event will be fired.
   * @returns {Number} The length of the event listener array.
   *
   */

	}, {
		key: 'on',
		value: function on(event, listener) {
			var targetArray = this.observers[event] || (this.observers[event] = []);

			return targetArray.push(listener);
		}

		/**
   * Triggers the event of the given name with optional data.
   *
   * @todo Support for multiple arguments.
   * @param event {String} The name of the event to trigger.
   * @param data {*} The data to pass to all listeners.
   *
   */

	}, {
		key: 'trigger',
		value: function trigger(event, data) {
			var value = undefined;
			var key = undefined;

			for (value = this.observers[event], key = 0; value && key < value.length;) {
				value[key++](data);
			}
		}

		/**
   * Removes the given listener function from the event of the given name.
   * @param event {String} Name of the event.
   * @param listener {Function} The listener function to remove.
   */

	}, {
		key: 'off',
		value: function off(event, listener) {
			var value = undefined;
			var key = undefined;

			for (value = this.observers[event] || []; listener && (key = value.indexOf(listener)) > -1;) {
				value.splice(key, 1);
			}

			this.observers[event] = listener ? value : [];
		}
	}]);

	return ComponentClass;
}();

//
// First, we export the named `@component` decorator, for simplified usage.
//


var component = exports.component = function component(decoratorPropTypes) {
	return function (CustomComponent) {
		var prototype = extractFrom(CustomComponent);
		var propTypes = decoratorPropTypes || CustomComponent.propTypes;

		return function Wrapper(el, props) {
			var BaseComponent = ComponentClass;

			//
			// Since the base class gets executed first, we need to transfer / reset the
			// getDefaultProps() and getInitialState() method.
			//
			if (prototype.getDefaultProps) {
				BaseComponent.prototype.getDefaultProps = prototype.getDefaultProps;
			} else {
				BaseComponent.prototype.getDefaultProps = ComponentClass.prototype.getDefaultProps;
			}
			if (prototype.getInitialState) {
				BaseComponent.prototype.getInitialState = prototype.getInitialState;
			} else {
				BaseComponent.prototype.getInitialState = ComponentClass.prototype.getInitialState;
			}

			//
			// Create an instance of the component.
			//
			BaseComponent.propTypes = propTypes;
			var base = new BaseComponent(el, props);
			BaseComponent.propTypes = {};

			//
			// Adjust the prototype of the actual component.
			//
			CustomComponent.prototype = base;

			//
			// Inject the prototype of the `CustomComponent`. This will
			// merge the attributes and the methods of the `CustomComponent`
			// with those from `@reduct/component`.
			//
			injectInto(CustomComponent, prototype);

			return new CustomComponent();
		};
	};
};

//
// And the ES6 class as the default export for users who would like to use it the traditional way.
//
exports.default = ComponentClass;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./messages.js":4,"./utilities/":6,"@reduct/logger":1}],4:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var noElement = exports.noElement = 'No element was specified while creating a instance of a Class. Creating a detached DOM Element instead.';
var extendDeprecate = exports.extendDeprecate = '@reduct/component.extend() is deprecated since v1.0.7 - Use the native ES6 extend instead.';

},{}],5:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.cloneObject = cloneObject;
/**
 * Deep-Clones a object.
 *
 * @param obj {Object} The object to clone.
 * @returns {Object} The cloned object.
 */
function cloneObject() {
	var obj = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	var target = {};

	for (var i in obj) {
		if (obj.hasOwnProperty(i)) {
			target[i] = obj[i];
		}
	}

	return target;
}

},{}],6:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.prototype = exports.isFunction = exports.isObject = exports.isError = exports.isDefined = exports.cloneObject = undefined;

var _cloneObject = _dereq_('./cloneObject.js');

var _isDefined = _dereq_('./isDefined.js');

var _isError = _dereq_('./isError.js');

var _isObject = _dereq_('./isObject.js');

var _isFunction = _dereq_('./isFunction.js');

var _prototype = _dereq_('./prototype.js');

exports.cloneObject = _cloneObject.cloneObject;
exports.isDefined = _isDefined.isDefined;
exports.isError = _isError.isError;
exports.isObject = _isObject.isObject;
exports.isFunction = _isFunction.isFunction;
exports.prototype = _prototype.prototype;

},{"./cloneObject.js":5,"./isDefined.js":7,"./isError.js":8,"./isFunction.js":9,"./isObject.js":10,"./prototype.js":11}],7:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDefined = isDefined;
/**
 * Checks if the given argument is defined and not `null`.
 *
 * @param val {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isDefined(val) {
  return val !== null && val !== undefined;
}

},{}],8:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isError = isError;
/**
 * Checks if the given argument is an instance of the Error Object.
 *
 * @param val {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isError(val) {
  return val instanceof Error;
}

},{}],9:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFunction = isFunction;
/**
 * Checks if the given argument is a function.
 *
 * @param func {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isFunction(func) {
  return typeof func === 'function';
}

},{}],10:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.isObject = isObject;
/**
 * Checks if the given argument is a object.
 *
 * @param obj {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isObject(obj) {
  return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj !== 'function' && obj !== null;
}

},{}],11:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
var prototype = exports.prototype = {
	extractFrom: function extractFrom(Target) {
		var prototype = {};

		Reflect.ownKeys(Target.prototype).forEach(function (key) {
			if (key !== 'constructor') {
				prototype[key] = Target.prototype[key];
			}
		});

		return prototype;
	},
	injectInto: function injectInto(Target, prototype) {
		for (var key in prototype) {
			if (prototype.hasOwnProperty(key)) {
				Target.prototype[key] = prototype[key];
			}
		}
	}
};

},{}]},{},[3])(3)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],7:[function(require,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.reduct || (g.reduct = {})).nitpick = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _abstractValidator = _dereq_('./abstractValidator.js');

var _abstractValidator2 = _interopRequireDefault(_abstractValidator);

var _utilities = _dereq_('./utilities/');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Applies a general check for the existence of a value.
 *
 * @param fn {*} The optional validator function which will be executed after the check.
 * @returns {Function} The curry function which will be wrapped around the validator.
 *
 */

exports.default = function (fn) {
	return (0, _abstractValidator2.default)(function (val) {
		var isValueDefined = (0, _utilities.isDefined)(val);

		if (!isValueDefined) {
			return new Error('The value is required but is either "undefined" or "null".');
		}

		return (0, _utilities.isFunction)(fn) ? fn(val) : val;
	});
};

},{"./abstractValidator.js":2,"./utilities/":12}],2:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Reduces the overall amount of code to align the @reduct/nitpick validators to the validator scheme.
 *
 * @param fn {*} The validator function which will be executed via FP.
 * @returns {Function} The curry function which will be wrapped around the validator.
 *
 */

exports.default = function (fn) {
  return function (props, propName) {
    return fn(props[propName]);
  };
};

},{}],3:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isOptional = exports.isRequired = undefined;

var _abstractRequiredValidator = _dereq_('./abstractRequiredValidator.js');

var _abstractRequiredValidator2 = _interopRequireDefault(_abstractRequiredValidator);

var _abstractValidator = _dereq_('./abstractValidator.js');

var _abstractValidator2 = _interopRequireDefault(_abstractValidator);

var _utilities = _dereq_('./utilities/');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Represents a general required check against a value.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an Error of the passed value if defined.
 *
 */
var isRequired = exports.isRequired = (0, _abstractRequiredValidator2.default)();

/**
 * Represents a general optional check against a value.
 *
 * @param val {*} The value which will be validated.
 * @returns {*} Either an undefined or the value which was passed to the validator.
 *
 */
var isOptional = exports.isOptional = (0, _abstractValidator2.default)(function (val) {
  var isValueDefined = (0, _utilities.isDefined)(val);

  // Fail safe to have a conssitent return value
  // if "null" was passed as the value.
  if (!isValueDefined) {
    return undefined;
  }

  return val;
});

},{"./abstractRequiredValidator.js":1,"./abstractValidator.js":2,"./utilities/":12}],4:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.isOptional = exports.isRequired = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _abstractRequiredValidator = _dereq_('./abstractRequiredValidator.js');

var _abstractRequiredValidator2 = _interopRequireDefault(_abstractRequiredValidator);

var _abstractValidator = _dereq_('./abstractValidator.js');

var _abstractValidator2 = _interopRequireDefault(_abstractValidator);

var _utilities = _dereq_('./utilities/');

var _any = _dereq_('./any.js');

var any = _interopRequireWildcard(_any);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Extends the general required validator for the type `Boolean`.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an Error of the passed value if defined.
 *
 */
var isRequired = exports.isRequired = (0, _abstractRequiredValidator2.default)(function (val) {
	var convertedBoolean = (0, _utilities.convertStringBoolean)(val);
	var isValueNotBool = !(0, _utilities.isBoolean)(convertedBoolean);

	if (isValueNotBool) {
		return new Error('The value is required and must be a "Boolean", instead got "' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + '".');
	}

	return convertedBoolean;
});

/**
 * Extends the general optional validator for the type `Boolean`.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an error or the value which was passed to the validator.
 *
 */
var isOptional = exports.isOptional = (0, _abstractValidator2.default)(function (val) {
	var convertedBoolean = (0, _utilities.convertStringBoolean)(val);
	var isValueNotBool = !(0, _utilities.isBoolean)(convertedBoolean);

	if ((0, _utilities.isDefined)(val) && isValueNotBool) {
		return new Error('The value is optional, but must be a "Boolean", instead got "' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + '".');
	}

	return convertedBoolean;
});

},{"./abstractRequiredValidator.js":1,"./abstractValidator.js":2,"./any.js":3,"./utilities/":12}],5:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _any = _dereq_('./any.js');

var any = _interopRequireWildcard(_any);

var _bool = _dereq_('./bool.js');

var bool = _interopRequireWildcard(_bool);

var _number = _dereq_('./number.js');

var number = _interopRequireWildcard(_number);

var _object = _dereq_('./object.js');

var object = _interopRequireWildcard(_object);

var _string = _dereq_('./string.js');

var string = _interopRequireWildcard(_string);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
	any: any,
	bool: bool,
	number: number,
	object: object,
	string: string
};

},{"./any.js":3,"./bool.js":4,"./number.js":6,"./object.js":7,"./string.js":8}],6:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.isOptional = exports.isRequired = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _abstractRequiredValidator = _dereq_('./abstractRequiredValidator.js');

var _abstractRequiredValidator2 = _interopRequireDefault(_abstractRequiredValidator);

var _abstractValidator = _dereq_('./abstractValidator.js');

var _abstractValidator2 = _interopRequireDefault(_abstractValidator);

var _utilities = _dereq_('./utilities/');

var _any = _dereq_('./any.js');

var any = _interopRequireWildcard(_any);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Extends the general required validator for the type `Number`.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an error or the value if it is a valid Boolean.
 *
 */
var isRequired = exports.isRequired = (0, _abstractRequiredValidator2.default)(function (val) {
	var convertedNumber = (0, _utilities.isString)(val) ? Math.abs(val) : val;
	var isNumber = (0, _utilities.isNumeric)(convertedNumber);

	if (!isNumber) {
		return new Error('The value is required and must be a "Number", instead got "' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + '".');
	}

	return convertedNumber;
});

/**
 * Extends the general optional validator for the type `Number`.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an error or the value which was passed to the validator.
 *
 */
var isOptional = exports.isOptional = (0, _abstractValidator2.default)(function (val) {
	var convertedNumber = (0, _utilities.isString)(val) ? Math.abs(val) : val;
	var isValueNotNumeric = !(0, _utilities.isNumeric)(convertedNumber);

	if ((0, _utilities.isDefined)(val) && isValueNotNumeric) {
		return new Error('The value is optional, but must be a "Number", instead got "' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + '".');
	}

	return convertedNumber;
});

},{"./abstractRequiredValidator.js":1,"./abstractValidator.js":2,"./any.js":3,"./utilities/":12}],7:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.isOptional = exports.isRequired = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _abstractRequiredValidator = _dereq_('./abstractRequiredValidator.js');

var _abstractRequiredValidator2 = _interopRequireDefault(_abstractRequiredValidator);

var _abstractValidator = _dereq_('./abstractValidator.js');

var _abstractValidator2 = _interopRequireDefault(_abstractValidator);

var _utilities = _dereq_('./utilities/');

var _any = _dereq_('./any.js');

var any = _interopRequireWildcard(_any);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Extends the general required validator for the type `Object`.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an Error of the passed value if defined.
 *
 */
var isRequired = exports.isRequired = (0, _abstractRequiredValidator2.default)(function (val) {
	// Try to convert the value to a JSON object.
	try {
		val = JSON.parse(val);
	} catch (e) {}

	if (!(0, _utilities.isObject)(val)) {
		return new Error('The value is required and must be a "Object", instead got "' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + '".');
	}

	return val;
});

/**
 * Extends the general optional validator for the type `Boolean`.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an error or the value which was passed to the validator.
 *
 */
var isOptional = exports.isOptional = (0, _abstractValidator2.default)(function (val) {
	// Try to convert the value to a JSON object.
	try {
		val = JSON.parse(val);
	} catch (e) {}

	if ((0, _utilities.isDefined)(val) && !(0, _utilities.isObject)(val)) {
		return new Error('The value is optional, but must be a "Object", instead got "' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + '".');
	}

	return val;
});

},{"./abstractRequiredValidator.js":1,"./abstractValidator.js":2,"./any.js":3,"./utilities/":12}],8:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.isOptional = exports.isRequired = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _abstractRequiredValidator = _dereq_('./abstractRequiredValidator.js');

var _abstractRequiredValidator2 = _interopRequireDefault(_abstractRequiredValidator);

var _abstractValidator = _dereq_('./abstractValidator.js');

var _abstractValidator2 = _interopRequireDefault(_abstractValidator);

var _utilities = _dereq_('./utilities/');

var _any = _dereq_('./any.js');

var any = _interopRequireWildcard(_any);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Extends the general required validator for the type `String`.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an Error of the passed value if defined.
 *
 */
var isRequired = exports.isRequired = (0, _abstractRequiredValidator2.default)(function (val) {
	var isValueNotValidString = !(0, _utilities.isString)(val);

	if (isValueNotValidString) {
		return new Error('The value is required and must be a "String", instead got "' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + '".');
	}

	return val;
});

/**
 * Extends the general optional validator for the type `String`.
 *
 * @param val {*} The value which will be validated.
 * @returns {Error|*} Either an error or the value which was passed to the validator.
 *
 */
var isOptional = exports.isOptional = (0, _abstractValidator2.default)(function (val) {
	var isValueNoString = !(0, _utilities.isString)(val);

	if ((0, _utilities.isDefined)(val) && isValueNoString) {
		return new Error('The value is optional, but must be a "String", instead got "' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + '".');
	}

	return (0, _utilities.isDefined)(val) ? val : undefined;
});

},{"./abstractRequiredValidator.js":1,"./abstractValidator.js":2,"./any.js":3,"./utilities/":12}],9:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.combinePropTypes = undefined;

var _isError = _dereq_('./isError');

/**
 * Combines several propTypes. The first one that returns an error will
 * end the execution chain.
 *
 * @param ...propTypes {...Function} The propTypes that will be combined
 * @returns {Function}
 *
 */
var combinePropTypes = exports.combinePropTypes = function combinePropTypes() {
  for (var _len = arguments.length, propTypes = Array(_len), _key = 0; _key < _len; _key++) {
    propTypes[_key] = arguments[_key];
  }

  return function (props, propName) {
    for (var i = 0, len = propTypes.length - 1; i < len; i++) {
      var validationResult = propTypes[i](props, propName);
      if ((0, _isError.isError)(validationResult)) {
        return validationResult;
      }
    }

    return propTypes[propTypes.length - 1](props, propName);
  };
};

},{"./isError":16}],10:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Compose various functions.
 *
 * @param ...funcs {...Function} The functions that will be composed
 * @returns {Function}
 *
 */
var compose = exports.compose = function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  return function (arg) {
    return funcs.reverse().reduce(function (currentValue, nextFunction) {
      return nextFunction(currentValue);
    }, arg);
  };
};

},{}],11:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.convertStringBoolean = convertStringBoolean;
/**
 * Converts a string containing a boolean to a real boolean if necessary.
 *
 * @param val
 * @returns {*}
 *
 */
function convertStringBoolean(val) {
	if (val === 'false') {
		val = false;
	}

	if (val === 'true') {
		val = true;
	}

	return val;
}

},{}],12:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.isString = exports.isObject = exports.isNumeric = exports.isFunction = exports.isError = exports.isDefined = exports.isBoolean = exports.isArray = exports.convertStringBoolean = exports.compose = exports.combinePropTypes = undefined;

var _combinePropTypes = _dereq_('./combinePropTypes.js');

var _compose = _dereq_('./compose.js');

var _convertStringBoolean = _dereq_('./convertStringBoolean.js');

var _isArray = _dereq_('./isArray.js');

var _isBoolean = _dereq_('./isBoolean.js');

var _isDefined = _dereq_('./isDefined.js');

var _isError = _dereq_('./isError.js');

var _isFunction = _dereq_('./isFunction.js');

var _isNumeric = _dereq_('./isNumeric.js');

var _isObject = _dereq_('./isObject.js');

var _isString = _dereq_('./isString.js');

exports.combinePropTypes = _combinePropTypes.combinePropTypes;
exports.compose = _compose.compose;
exports.convertStringBoolean = _convertStringBoolean.convertStringBoolean;
exports.isArray = _isArray.isArray;
exports.isBoolean = _isBoolean.isBoolean;
exports.isDefined = _isDefined.isDefined;
exports.isError = _isError.isError;
exports.isFunction = _isFunction.isFunction;
exports.isNumeric = _isNumeric.isNumeric;
exports.isObject = _isObject.isObject;
exports.isString = _isString.isString;

},{"./combinePropTypes.js":9,"./compose.js":10,"./convertStringBoolean.js":11,"./isArray.js":13,"./isBoolean.js":14,"./isDefined.js":15,"./isError.js":16,"./isFunction.js":17,"./isNumeric.js":18,"./isObject.js":19,"./isString.js":20}],13:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.isArray = isArray;
/**
 * Checks if the given argument is an array.
 *
 * @param arr {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isArray(arr) {
  return arr !== null && (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Array.isArray(arr);
}

},{}],14:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBoolean = isBoolean;
/**
 * Checks if the given argument is a boolean or a string containing a boolean.
 *
 * @param bol {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isBoolean(bol) {
  return typeof bol === 'boolean' || bol === 'true' || bol === 'false';
}

},{}],15:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDefined = isDefined;
/**
 * Checks if the given argument is defined and not `null`.
 *
 * @param val {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isDefined(val) {
  return val !== null && val !== undefined;
}

},{}],16:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isError = isError;
/**
 * Checks if the given argument is an instance of the Error Object.
 *
 * @param val {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isError(val) {
  return val instanceof Error;
}

},{}],17:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFunction = isFunction;
/**
 * Checks if the given argument is a function.
 *
 * @param func {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isFunction(func) {
  return typeof func === 'function';
}

},{}],18:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNumeric = isNumeric;
/**
 * Checks if the given argument is a Number.
 *
 * @param num {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isNumeric(num) {
  return !isNaN(num) && num !== null && num !== true && num !== false;
}

},{}],19:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.isObject = isObject;
/**
 * Checks if the given argument is a object.
 *
 * @param obj {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isObject(obj) {
  return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null;
}

},{}],20:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isString = isString;
/**
 * Checks if the given argument is a string.
 *
 * @param str {*} The argument which will be validated.
 * @returns {boolean}
 *
 */
function isString(str) {
  return typeof str === 'string';
}

},{}]},{},[5])(5)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],8:[function(require,module,exports){
function getClassesNotInElement( el, cssClasses ) {
  var classes = el.className.split( /\s+/ ).reduce( function ( seq, current ) {
    seq[ current ] = true;
    return seq;
  }, { } );

  return cssClasses.filter( function ( klass ) {
    return !classes[ klass ];
  } );
}

module.exports = function () {
  var args = [ ].slice.call( arguments );
  var elements = args.shift();

  if ( !Array.isArray( elements ) ) {
    elements = [ elements ];
  }

  args = args.reduce( function ( seq, cName ) {
    if ( typeof cName !== 'string' ) {
      throw new Error( 'addClass expects a string' );
    }
    cName = cName.trim();
    if ( cName ) {
      seq = seq.concat( cName.split( /\s+/ ) );
    }
    return seq;
  }, [ ] );

  elements.forEach( function ( el ) {
    if ( el.classList ) {
      args.forEach( function ( cName ) {
        el.classList.add( cName );
      } );

    } else {
      args = getClassesNotInElement( el, args );
      if ( args.length > 0 ) {
        var className = args.join( ' ' );
        el.className += ' ' + className;
      }
    }
  } );
};

},{}],9:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],10:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter

var hashchange = module.exports = new EventEmitter()

window.addEventListener('hashchange', function () {
  hashchange.emit('change', hashchange.hash())
})

hashchange.hash = function () {
  return window.location.hash.substring(1)
}

},{"events":9}],11:[function(require,module,exports){
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      this.map[name].forEach(function(value) {
        callback.call(thisArg, value, name, this)
      }, this)
    }, this)
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    reader.readAsArrayBuffer(blob)
    return fileReaderReady(reader)
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    reader.readAsText(blob)
    return fileReaderReady(reader)
  }

  var support = {
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  function Body() {
    this.bodyUsed = false


    this._initBody = function(body) {
      this._bodyInit = body
      if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (!body) {
        this._bodyText = ''
      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
        // Only support ArrayBuffers for POST method.
        // Receiving ArrayBuffers happens via Blobs, instead.
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        return this.blob().then(readBlobAsArrayBuffer)
      }

      this.text = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      }
    } else {
      this.text = function() {
        var rejected = consumed(this)
        return rejected ? rejected : Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body
    if (Request.prototype.isPrototypeOf(input)) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = input
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this)
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function headers(xhr) {
    var head = new Headers()
    var pairs = xhr.getAllResponseHeaders().trim().split('\n')
    pairs.forEach(function(header) {
      var split = header.trim().split(':')
      var key = split.shift().trim()
      var value = split.join(':').trim()
      head.append(key, value)
    })
    return head
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = options.status
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = options.statusText
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request
      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input
      } else {
        request = new Request(input, init)
      }

      var xhr = new XMLHttpRequest()

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL
        }

        // Avoid security warnings on getResponseHeader when not allowed by CORS
        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL')
        }

        return;
      }

      xhr.onload = function() {
        var status = (xhr.status === 1223) ? 204 : xhr.status
        if (status < 100 || status > 599) {
          reject(new TypeError('Network request failed'))
          return
        }
        var options = {
          status: status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        }
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);

},{}]},{},[4]);
